S = 100
L = 130
K = 100

def recursive_name(u,d,n):
    if n <=1:
        return [u,d]
    else:
        te = recursive_name(u,d,n-1)
        total_list = []
        for i2 in te:
            for i1 in [u,d]:
                total_list.append(i2+i1)
        return total_list

def cal_exotic_option(s,x,l,u,d,n,t,r):
    p = (1-d)/(u-d)
    p_inv = 1-p
    temp = np.ones((2**n,n+2))*s
    price_df = pd.DataFrame(temp, columns=['w']+[f'P({i})' for i in range(n+1)])
    price_df['w'] = recursive_name('u','d',n)
    def cal_price_prob(a1,i1,u1,d1,s1,t1):
        te_str = a1['w'][:i1]
        u_count = te_str.count('u')
        d_count = te_str.count('d')
        if t1=='price':
            return s1*(u1**u_count)*(d1**d_count)
        elif t1=='prob':
            return (p**u_count)*(p_inv**d_count)
    for i in range(n+1):
        price_df[f'P({i})'] = price_df.apply(cal_price_prob,args=[i,u,d,s,'price'],axis=1)
    price_df['Prob'] = price_df.apply(cal_price_prob,args=[i,u,d,s,'prob'],axis=1)
    price_df['Value']= s
    price_df_temp = price_df[[f'P({i})' for i in range(n+1)]]
    for i in range(len(price_df.index)):
        ma = max(price_df_temp.loc[i].values)
        if ma > l:
            price_df['Value'].loc[i] = 0
        else:
            if price_df[f'P({n})'].loc[i] <= x:
                price_df['Value'].loc[i] = 0
            else:
                price_df['Value'].loc[i] = price_df[f'P({n})'].loc[i] - x
                
    price_df['Temp'] =price_df['Prob'] *price_df['Value']
    print(f'The value of UAO European call option is: {sum(price_df["Temp"].values):.3f}')
    price_df = price_df.drop(['Temp'],axis=1)
    return price_df
